在 Go 语言中，`init()` 是一种特殊的函数，用于初始化代码。每个 Go 文件都可以包含一个 `init()` 函数，它会在程序的 `main()` 函数执行之前，自动调用。`init()` 不需要手动调用，也不能带有参数或返回值。

### `init()` 的执行机制

1. **自动调用**：`init()` 函数在包导入后自动执行，不需要显式调用。
2. **执行顺序**：
   - **包级别的变量初始化**：Go 程序首先会初始化包级别的变量。
   - **`init()` 执行**：然后调用每个文件中的 `init()` 函数，顺序是按照包导入的顺序。
   - **`main()` 执行**：在所有导入的包的 `init()` 函数都执行完毕后，`main()` 函数才会被执行。

### 重要规则

- 每个包可以有多个 `init()` 函数，甚至同一个源文件可以定义多个 `init()`，这些 `init()` 函数将按出现顺序依次执行。
- 每个源文件（`.go` 文件）可以定义自己的 `init()` 函数。
- 包导入时，`init()` 只会执行一次，无论该包被导入多少次。

### 示例

```go
package main

import (
    "fmt"
)

var message string

// 包级变量初始化
func init() {
    message = "Hello, Go!"
    fmt.Println("init() called")
}

func main() {
    fmt.Println(message)
}
```

**执行顺序**：
1. Go 首先初始化包级别的变量。
2. 然后调用 `init()` 函数，打印 `"init() called"`。
3. 最后执行 `main()`，打印 `"Hello, Go!"`。

### `init()` 的适用场景

`init()` 通常用于程序初始化的特殊场景，包括但不限于：

1. **初始化包内全局变量**：如果全局变量的初始化过程较为复杂，可以放在 `init()` 中进行。
2. **配置文件或环境变量加载**：例如，可以在 `init()` 中读取配置文件、初始化日志系统、加载环境变量等。
3. **注册和依赖注入**：某些场景下，初始化某些注册表、依赖注入框架时适合使用 `init()`。
4. **与第三方库的集成**：可以在 `init()` 中设置第三方库的初始配置，确保它们在使用前已经完成初始化。

### 示例：用于初始化配置文件

```go
package config

import (
    "fmt"
    "os"
)

var appConfig map[string]string

func init() {
    // 在程序启动时初始化配置
    appConfig = make(map[string]string)
    appConfig["DB_HOST"] = os.Getenv("DB_HOST")
    appConfig["DB_PORT"] = os.Getenv("DB_PORT")
    
    if appConfig["DB_HOST"] == "" {
        appConfig["DB_HOST"] = "localhost" // 设置默认值
    }
    
    fmt.Println("Configuration initialized:", appConfig)
}
```

**适用场景**：
- 当我们需要在包加载时读取环境变量、配置文件并初始化到某个全局变量中时，`init()` 是一个理想的选择。

### `init()` 方法的限制与注意事项

1. **尽量保持简洁**：`init()` 的目的是初始化，而不是进行复杂的逻辑运算或大规模的数据处理，避免过多逻辑导致程序难以维护。
2. **不可预测性**：过度使用 `init()` 可能使程序的行为变得不可预测，尤其是在多个包的 `init()` 函数相互依赖时。
3. **依赖管理**：由于 `init()` 函数在包导入时执行，多个包的初始化顺序需要仔细管理，避免依赖问题。

### 总结
- `init()` 在 Go 中用于初始化，在程序执行 `main()` 函数之前执行。
- 适合用于**全局变量初始化**、**加载配置**、**第三方库初始化**等场景。
- 应当避免在 `init()` 中编写过于复杂的逻辑，并保证初始化的可预测性和可维护性。
